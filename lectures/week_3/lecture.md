# Тема: «Множества»

## 1. Как устроено множество?

### Что должно уметь делать множество?

* Добавлять элемент

* Проверять наличие элемента

* Удалять элемент

### Как устроено множество?

* Придумаем какую-нибудь функцию, которая сопоставляет 
каждому элементу какое-либо небольшое число

* Вычислим функцию от элемента

* Положим элемент в список с номером, равным значению
функции

### Время выполнения в множестве

* Перебирание всех элементов: O(N + K) 

* Проверка элемента: O(n)

* Поиск элемента в среднем случае: O(K / N)

* Удаление элемента: O(1) 

> ✅ task_0.py 

* F(x) = x % set_size ==> хеш-функция

* my_set (список списков) ==> хеш-таблица

* Совпадение значений хеш-функции для разных 
параметров ==> коллизия

### Что можно хранить в множестве эффективно?

* Эффективно - только **неизменяемые** объекты

* Для неизменяемых объектов можно посчитать значение хеш-функции при их создании.

* Хеш-функция должна давать равномерное распределение

## 2. Амортизированная сложность

### Проблемы с хеш-таблицей

* Слишком большой размер — ест много памяти **O(N)**

* Слишком маленький размер — большой коэффициент 
заполнения и медленный поиск и удаление **O(K / N)**

* Хочется иметь разумный баланс, например, коэффициент
заполнения не больше единицы (т.е. **K <= N**). 
Тогда все операции в среднем будут занимать **O(1)**

### Решение проблемы с хеш-таблицей

* Когда таблица наполнится - увеличим ее размер вдвое
и перестроим! Перестроение таблицы за O(n)

* Возьмем таблицу с начальным размером 1

* Будем добавлять N = 2^P элементов, т.е. P = logN

* Только на P шагах (когда размер таблицы равен
очередной степени двойки) может произойти
перестроение таблицы за O(N)

* 1 + 2 + 4 + 8 + ... + 2^P = 2^P - 1 = 2N - 1 = O(n)

### Амортизированная сложность

* Амортизированная сложность — среднее время выполнения операции (условно)

* У нас амортизированная сложность операции **O(1)** — 
всего было **N** операций и суммарно ушло **O(N)**

* В худшем случае отдельная операция выполняется за **O(N)** 
— может не происходить в системах реального времени

> ✅ task_1.py 

> ✅ task_2.py 